{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dot-pattern",
  "title": "Dot Pattern",
  "description": "Dot grid background pattern component.",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/dot-pattern.tsx",
      "content": "import { useId, useRef, useEffect, useState } from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\ntype DotPatternProps = {\n  width?: number;\n  height?: number;\n  x?: number;\n  y?: number;\n  cx?: number;\n  cy?: number;\n  cr?: number;\n  shape?: \"circle\" | \"square\" | \"cross\";\n  strokeWidth?: number;\n  mode?: \"orthogonal\" | \"staggered\";\n  color?: string;\n  opacity?: number;\n  fade?: boolean;\n  fadeLevel?: \"weak\" | \"medium\" | \"strong\";\n  fadeReverse?: boolean;\n  effect?: \"glow\" | \"scan\" | \"pulse\" | \"none\";\n  effectPlaying?: boolean;\n  effectMaxScale?: number;\n  effectMaxOpacity?: number;\n  effectColor?: string;\n  effectSize?: number;\n\n  hover?: boolean;\n  hoverRadius?: number;\n  hoverTargetScale?: number;\n  hoverTargetOpacity?: number;\n  hoverColor?: string;\n  hoverTrail?: boolean;\n  hoverTrailDuration?: number;\n\n  className?: string;\n  [key: string]: unknown;\n};\n\nexport function DotPattern({\n  width = 16,\n  height = 16,\n  x = 0,\n  y = 0,\n  cx = 1,\n  cy = 1,\n  cr = 1,\n  shape = \"circle\",\n  strokeWidth,\n  mode = \"orthogonal\",\n  color = \"#000000\",\n  opacity = 0.05,\n  fade = false,\n  fadeLevel = \"weak\",\n  fadeReverse = false,\n  effect = \"none\",\n  effectPlaying = false,\n  effectMaxScale = 1.8,\n  effectMaxOpacity = 0.8,\n  effectColor,\n  effectSize = 150,\n\n  hover = false,\n  hoverRadius = 120,\n  hoverTargetScale = 1.8,\n  hoverTargetOpacity = 0.8,\n  hoverColor,\n  hoverTrail = false,\n  hoverTrailDuration = 1.0,\n\n  className,\n  ...props\n}: DotPatternProps) {\n  const id = useId();\n  const maskId = `${id}-mask`;\n  const gradientId = `${id}-gradient`;\n  const offset = mode === \"staggered\" ? { x: width / 2, y: height / 2 } : null;\n  const size = cr * 2;\n  const currentStrokeWidth = strokeWidth ?? 1;\n\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const mousePosRef = useRef({ x: -9999, y: -9999 }); // Use ref for performance and to avoid re-renders\n  const trailGridRef = useRef<Float32Array | null>(null);\n  const lastMousePos = useRef({ x: -9999, y: -9999 });\n  const lastMouseTime = useRef(0);\n  const mouseSpeed = useRef(0);\n  \n  // Use passed effect colors or fallback to base color\n  const activeEffectColor = effectColor ?? color;\n  const activeHoverColor = hoverColor ?? color;\n\n  // Easing helpers for effect timing\n  const easeIn = (t: number) => t * t * t;\n  const easeOut = (t: number) => 1 - Math.pow(1 - t, 3);\n  const easeInOut = (t: number) =>\n    t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n  const getEasedValue = (t: number) => {\n    switch (effectEase) {\n      case \"ease-in\":\n        return easeIn(t);\n      case \"ease-out\":\n        return easeOut(t);\n      case \"ease-in-out\":\n        return easeInOut(t);\n      default:\n        return t;\n    }\n  };\n\n  useEffect(() => {\n    // Only run canvas logic if effects are enabled or hover is on\n    if (effect === \"none\" && !hover) {\n      if (canvasRef.current) {\n        const ctx = canvasRef.current.getContext(\"2d\");\n        if (ctx) ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n      }\n      return;\n    }\n\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    let animationFrameId: number;\n    let startTime = performance.now();\n    let lastTime = startTime;\n\n    const render = (timestamp: number) => {\n      if (!containerRef.current) return;\n      \n      const { width: containerWidth, height: containerHeight } = containerRef.current.getBoundingClientRect();\n      const dt = (timestamp - lastTime) / 1000; // delta time in seconds\n      lastTime = timestamp;\n\n      // Update canvas size if needed (handling DPI)\n      const dpr = window.devicePixelRatio || 1;\n      if (canvas.width !== containerWidth * dpr || canvas.height !== containerHeight * dpr) {\n        canvas.width = containerWidth * dpr;\n        canvas.height = containerHeight * dpr;\n        canvas.style.width = `${containerWidth}px`;\n        canvas.style.height = `${containerHeight}px`;\n        // Reset trail grid on resize\n        trailGridRef.current = null;\n      }\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.save();\n      ctx.scale(dpr, dpr);\n\n      // Pre-calculate common values\n      const cols = Math.ceil(containerWidth / width);\n      const rows = Math.ceil(containerHeight / height);\n      const totalDots = cols * rows;\n\n      // Initialize trail grid if needed\n      if (hoverTrail && (!trailGridRef.current || trailGridRef.current.length !== totalDots)) {\n        trailGridRef.current = new Float32Array(totalDots);\n      } else if (!hoverTrail) {\n        trailGridRef.current = null;\n      }\n      \n      // Time-based variables for effects\n      const time = effectPlaying ? (timestamp - startTime) / 1000 : 0;\n      \n      // Scan effect variables\n      const scanWidth = effectSize; \n      // Scan cycle is effectDuration\n      const scanDistance = containerWidth + scanWidth * 2;\n      const scanProgress = (time % effectDuration) / effectDuration;\n      const easedScanProgress = getEasedValue(scanProgress);\n      const scanX = easedScanProgress * scanDistance - scanWidth;\n\n      // Pulse effect variables\n      const pulseMaxRadius = Math.max(containerWidth, containerHeight);\n      const pulseProgress = (time % effectDuration) / effectDuration;\n      const easedPulseProgress = getEasedValue(pulseProgress);\n      const pulseRadius = easedPulseProgress * pulseMaxRadius;\n      const pulseWidth = effectSize;\n\n      // Draw dots\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          let dotX = j * width + cx + x;\n          let dotY = i * height + cy + y;\n\n          // Apply staggered offset\n          if (mode === \"staggered\" && i % 2 === 1) {\n            dotX += width / 2;\n          }\n\n          // Skip if outside container\n          if (dotX < -width || dotX > containerWidth + width || dotY < -height || dotY > containerHeight + height) continue;\n\n          // Calculate effect intensity (0 to 1)\n          let effectIntensity = 0;\n          let hoverIntensity = 0;\n\n          // Glow effect: Random-looking pulse for each dot\n          if (effect === \"glow\") {\n            // Improve randomness to avoid wave patterns\n            // Use a pseudo-random hash based on coordinates\n            const randomSeed = Math.abs(Math.sin(i * 12.9898 + j * 78.233) * 43758.5453); \n            const freq = 1 / effectDuration; \n            const phase = randomSeed * Math.PI * 2;\n            // Oscillate between 0 and 1\n            effectIntensity = (Math.sin(time * Math.PI * 2 * freq + phase) + 1) / 2;\n          }\n\n          // Scan effect: Vertical band moving right\n          if (effect === \"scan\") {\n            const dist = Math.abs(dotX - scanX);\n            if (dist < scanWidth) {\n              // Smooth falloff from center of scan band\n              effectIntensity = Math.pow(1 - dist / scanWidth, 2);\n            }\n          }\n\n          // Pulse effect: Ring expanding from center\n          if (effect === \"pulse\") {\n            const centerX = containerWidth / 2;\n            const centerY = containerHeight / 2;\n            const dist = Math.hypot(dotX - centerX, dotY - centerY);\n            const distFromRing = Math.abs(dist - pulseRadius);\n            \n            if (distFromRing < pulseWidth) {\n              effectIntensity = Math.pow(1 - distFromRing / pulseWidth, 2);\n            }\n          }\n\n          // Hover effect\n          if (hover) {\n            // Calculate distance to mouse\n            const dist = Math.hypot(dotX - mousePosRef.current.x, dotY - mousePosRef.current.y);\n            let instantHover = 0;\n            \n            if (dist < hoverRadius) {\n               // Base hover intensity from distance\n               instantHover = Math.pow(1 - dist / hoverRadius, 2);\n            }\n\n            if (hoverTrail && trailGridRef.current) {\n              const dotIndex = i * cols + j;\n              // If trail is enabled, we use the grid to store/decay values\n              \n              // Decay existing value\n              // Linear decay: value - (dt / duration)\n              // Or exponential: value * Math.pow(fraction, dt)\n              // Let's use linear for predictable duration\n              let currentTrail = trailGridRef.current[dotIndex] || 0;\n              currentTrail = Math.max(0, currentTrail - dt / hoverTrailDuration);\n\n              // Add new input if mouse is close\n              // If we have a trail, the intensity is boosted by mouse speed? \n              // User requirement: \"intensity depends on mouse speed\"\n              // Max speed assumption? Say 2000px/s = 1.0 intensity boost\n              if (dist < hoverRadius) {\n                 const speedFactor = Math.min(mouseSpeed.current / 1000, 1);\n                 // Only add if moving? \"mouse static produces no effect\"\n                 if (speedFactor > 0.01) {\n                    // Combine distance and speed\n                    const newIntensity = instantHover * speedFactor;\n                    // \"Fast change, slow restore\" -> Jump up quickly\n                    currentTrail = Math.max(currentTrail, newIntensity);\n                 }\n              }\n\n              trailGridRef.current[dotIndex] = currentTrail;\n              hoverIntensity = currentTrail;\n\n            } else {\n              // Standard hover\n              hoverIntensity = instantHover;\n            }\n          }\n\n          // Combine intensities\n          if (effectIntensity > 0.01 || hoverIntensity > 0.01) {\n             // Calculate properties for Effect\n             const effectScale = 1 + effectIntensity * (effectMaxScale - 1);\n             const effectOpacity = opacity + (effectMaxOpacity - opacity) * effectIntensity;\n             \n             // Calculate properties for Hover\n             const hoverScale = 1 + hoverIntensity * (hoverTargetScale - 1);\n             const hoverOpacity = opacity + (hoverTargetOpacity - opacity) * hoverIntensity;\n\n             // Combine: simple max for geometry\n             const currentScale = Math.max(effectScale, hoverScale);\n             const currentAlpha = Math.max(effectOpacity, hoverOpacity);\n             \n             // Color blending\n             let finalColor = activeEffectColor;\n\n             if (multiColor && multiColors && multiColors.length > 0) {\n                // Multi-Color Mode: Active dots get random color\n                // Use Golden Ratio for better distribution than previous 137.5 (which gave 0.5 steps)\n                const dotIndex = i * cols + j;\n                const phi = 0.618033988749895; \n                const seed = (dotIndex * phi) % 1; \n                \n                let cumulative = 0;\n                let found = false;\n                for (const item of multiColors) {\n                   cumulative += item.percent;\n                   if (seed * 100 < cumulative) {\n                      finalColor = item.color;\n                      found = true;\n                      break;\n                   }\n                }\n                // Fallback to last color if rounding errors or incomplete percentages\n                if (!found && multiColors.length > 0) {\n                    finalColor = multiColors[multiColors.length - 1].color;\n                }\n             } else {\n                 // Single Color Mode\n                 // Priority: Hover > Effect\n                 // Use intensity comparison to determine which color to show\n                 // This allows a strong effect (e.g. scan) to remain visible even if hover is weak\n                 // But if hover is strong (near mouse), it overrides effect\n                 if (hoverIntensity > effectIntensity) {\n                    finalColor = activeHoverColor;\n                 } else {\n                    finalColor = activeEffectColor;\n                 }\n             }\n\n             ctx.fillStyle = finalColor;\n             \n             // Apply alpha\n             ctx.globalAlpha = currentAlpha;\n            \n            // Draw shape\n            if (shape === \"square\") {\n              const s = size * currentScale;\n              ctx.fillRect(dotX - s/2, dotY - s/2, s, s);\n            } else if (shape === \"cross\") {\n              const s = size * currentScale;\n              const w = currentStrokeWidth * currentScale; \n              \n              ctx.beginPath();\n              // Vertical\n              ctx.rect(dotX - w/2, dotY - s/2, w, s);\n              // Horizontal\n              ctx.rect(dotX - s/2, dotY - w/2, s, w);\n              ctx.fill();\n            } else {\n              // Circle\n              ctx.beginPath();\n              ctx.arc(dotX, dotY, cr * currentScale, 0, Math.PI * 2);\n              ctx.fill();\n            }\n          }\n        }\n      }\n\n      ctx.restore();\n      if (effectPlaying || hover) {\n        animationFrameId = requestAnimationFrame(render);\n      }\n    };\n\n    if (effectPlaying || hover) {\n      animationFrameId = requestAnimationFrame(render);\n    } else {\n      // Draw once if paused but effect is enabled (to show static state) or hovered\n      render(performance.now());\n    }\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [\n    width, height, x, y, cx, cy, cr, shape, strokeWidth, mode, color, opacity, \n    effect, effectPlaying, effectEase, effectMaxScale, effectMaxOpacity, effectSize, effectDuration, activeEffectColor,\n    hover, hoverRadius, hoverTargetScale, hoverTargetOpacity, activeHoverColor, hoverTrail, hoverTrailDuration,\n    multiColor, multiColors, fade, fadeLevel, fadeReverse\n  ]);\n\n  // Update mouse position and calculate speed\n  const handleMouseMove = (e: React.MouseEvent) => {\n    if (!hover || !containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    const now = performance.now();\n    const dt = now - lastMouseTime.current;\n    \n    if (dt > 0) {\n      const dx = x - lastMousePos.current.x;\n      const dy = y - lastMousePos.current.y;\n      const dist = Math.hypot(dx, dy);\n      // Speed in px/s\n      mouseSpeed.current = (dist / dt) * 1000;\n    }\n\n    lastMousePos.current = { x, y };\n    lastMouseTime.current = now;\n    mousePosRef.current = { x, y };\n  };\n\n  const handleMouseLeave = () => {\n    mousePosRef.current = { x: -9999, y: -9999 };\n  };\n\n  const getGradientStops = () => {\n    switch (fadeLevel) {\n      case \"strong\":\n        return (\n          <>\n            <stop offset=\"0%\" stopColor={fadeReverse ? \"white\" : \"white\"} stopOpacity={fadeReverse ? 0 : 1} />\n            <stop offset=\"30%\" stopColor={fadeReverse ? \"white\" : \"white\"} stopOpacity={fadeReverse ? 0 : 1} />\n            <stop offset=\"70%\" stopColor={fadeReverse ? \"white\" : \"white\"} stopOpacity={fadeReverse ? 1 : 0} />\n            <stop offset=\"100%\" stopColor={fadeReverse ? \"white\" : \"white\"} stopOpacity={fadeReverse ? 1 : 0} />\n          </>\n        );\n      case \"medium\":\n        return (\n          <>\n            <stop offset=\"0%\" stopColor=\"white\" stopOpacity={fadeReverse ? 0 : 1} />\n            <stop offset=\"50%\" stopColor=\"white\" stopOpacity={fadeReverse ? 0 : 1} />\n            <stop offset=\"90%\" stopColor=\"white\" stopOpacity={fadeReverse ? 1 : 0} />\n            <stop offset=\"100%\" stopColor=\"white\" stopOpacity={fadeReverse ? 1 : 0} />\n          </>\n        );\n      case \"weak\":\n      default:\n        return (\n          <>\n            <stop offset=\"0%\" stopColor=\"white\" stopOpacity={fadeReverse ? 0 : 1} />\n            <stop offset=\"70%\" stopColor=\"white\" stopOpacity={fadeReverse ? 0 : 1} />\n            <stop offset=\"100%\" stopColor=\"white\" stopOpacity={fadeReverse ? 1 : 0} />\n          </>\n        );\n    }\n  };\n\n  const renderShape = (offsetX = 0, offsetY = 0) => {\n    if (shape === \"square\") {\n      return (\n        <rect\n          x={cx - cr + offsetX}\n          y={cy - cr + offsetY}\n          width={size}\n          height={size}\n          fill={color}\n          fillOpacity={opacity}\n        />\n      );\n    }\n\n    if (shape === \"cross\") {\n      return (\n        <g stroke={color} strokeOpacity={opacity}>\n          <line\n            x1={cx - cr + offsetX}\n            y1={cy + offsetY}\n            x2={cx + cr + offsetX}\n            y2={cy + offsetY}\n            strokeLinecap=\"round\"\n            strokeWidth={currentStrokeWidth}\n            vectorEffect=\"non-scaling-stroke\"\n          />\n          <line\n            x1={cx + offsetX}\n            y1={cy - cr + offsetY}\n            x2={cx + offsetX}\n            y2={cy + cr + offsetY}\n            strokeLinecap=\"round\"\n            strokeWidth={currentStrokeWidth}\n            vectorEffect=\"non-scaling-stroke\"\n          />\n        </g>\n      );\n    }\n\n    return (\n      <circle\n        id=\"pattern-circle\"\n        cx={cx + offsetX}\n        cy={cy + offsetY}\n        r={cr}\n        fill={color}\n        fillOpacity={opacity}\n      />\n    );\n  };\n\n  return (\n    <div \n      ref={containerRef}\n      className={cn(\"absolute inset-0 h-full w-full\", className)}\n      onMouseMove={handleMouseMove}\n      onMouseLeave={handleMouseLeave}\n      {...props}\n    >\n      <svg\n        aria-hidden=\"true\"\n        className=\"pointer-events-none absolute inset-0 h-full w-full\"\n      >\n        <defs>\n          <pattern\n            id={id}\n            width={width}\n            height={height}\n            patternUnits=\"userSpaceOnUse\"\n            patternContentUnits=\"userSpaceOnUse\"\n            x={x}\n            y={y}\n          >\n            {renderShape(0, 0)}\n            {offset ? renderShape(offset.x, offset.y) : null}\n          </pattern>\n          {fade ? (\n            <>\n              <radialGradient id={gradientId} cx=\"50%\" cy=\"50%\" r=\"70%\">\n                {getGradientStops()}\n              </radialGradient>\n              <mask id={maskId}>\n                <rect width=\"100%\" height=\"100%\" fill={`url(#${gradientId})`} />\n              </mask>\n            </>\n          ) : null}\n        </defs>\n        <rect\n          width=\"100%\"\n          height=\"100%\"\n          strokeWidth={0}\n          fill={`url(#${id})`}\n          mask={fade ? `url(#${maskId})` : undefined}\n        />\n      </svg>\n      {/* Canvas for effects overlay */}\n      {(effect !== \"none\" || hover) && (\n        <canvas\n          ref={canvasRef}\n          className=\"pointer-events-none absolute inset-0 h-full w-full\"\n        />\n      )}\n      {fade && (effect !== \"none\" || hover) && (\n        <style jsx>{`\n          canvas {\n            mask-image: radial-gradient(circle farthest-corner at 50% 50%, ${fadeReverse ? 'transparent' : 'black'} 0%, ${fadeReverse ? 'transparent' : 'black'} 70%, ${fadeReverse ? 'black' : 'transparent'} 100%);\n            -webkit-mask-image: radial-gradient(circle farthest-corner at 50% 50%, ${fadeReverse ? 'transparent' : 'black'} 0%, ${fadeReverse ? 'transparent' : 'black'} 70%, ${fadeReverse ? 'black' : 'transparent'} 100%);\n          }\n          ${fadeLevel === 'medium' ? `\n          canvas {\n            mask-image: radial-gradient(circle farthest-side at 50% 50%, ${fadeReverse ? 'transparent' : 'black'} 0%, ${fadeReverse ? 'transparent' : 'black'} 50%, ${fadeReverse ? 'black' : 'transparent'} 100%);\n            -webkit-mask-image: radial-gradient(circle farthest-side at 50% 50%, ${fadeReverse ? 'transparent' : 'black'} 0%, ${fadeReverse ? 'transparent' : 'black'} 50%, ${fadeReverse ? 'black' : 'transparent'} 100%);\n          }` : ''}\n          ${fadeLevel === 'strong' ? `\n          canvas {\n            mask-image: radial-gradient(circle closest-side at 50% 50%, ${fadeReverse ? 'transparent' : 'black'} 0%, ${fadeReverse ? 'transparent' : 'black'} 30%, ${fadeReverse ? 'black' : 'transparent'} 100%);\n            -webkit-mask-image: radial-gradient(circle closest-side at 50% 50%, ${fadeReverse ? 'transparent' : 'black'} 0%, ${fadeReverse ? 'transparent' : 'black'} 30%, ${fadeReverse ? 'black' : 'transparent'} 100%);\n          }` : ''}\n        `}</style>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:ui"
}