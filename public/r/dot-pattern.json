{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dot-pattern",
  "title": "Dot Pattern",
  "description": "Dot grid background pattern component.",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "registry/ui/dot-pattern.tsx",
      "content": "import { useId, useRef, useEffect, useState } from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\ntype DotPatternProps = {\n  width?: number;\n  height?: number;\n  x?: number;\n  y?: number;\n  cx?: number;\n  cy?: number;\n  cr?: number;\n  shape?: \"circle\" | \"square\" | \"cross\";\n  strokeWidth?: number;\n  mode?: \"orthogonal\" | \"staggered\";\n  color?: string;\n  opacity?: number;\n  fade?: boolean;\n  fadeLevel?: \"weak\" | \"medium\" | \"strong\";\n  effect?: \"glow\" | \"scan\" | \"pulse\" | \"none\";\n  effectPlaying?: boolean;\n  hover?: boolean;\n  className?: string;\n  [key: string]: unknown;\n};\n\nexport function DotPattern({\n  width = 16,\n  height = 16,\n  x = 0,\n  y = 0,\n  cx = 1,\n  cy = 1,\n  cr = 1,\n  shape = \"circle\",\n  strokeWidth,\n  mode = \"orthogonal\",\n  color = \"#000000\",\n  opacity = 0.05,\n  fade = false,\n  fadeLevel = \"weak\",\n  effect = \"none\",\n  effectPlaying = false,\n  hover = false,\n  className,\n  ...props\n}: DotPatternProps) {\n  const id = useId();\n  const maskId = `${id}-mask`;\n  const gradientId = `${id}-gradient`;\n  const offset = mode === \"staggered\" ? { x: width / 2, y: height / 2 } : null;\n  const size = cr * 2;\n  const currentStrokeWidth = strokeWidth ?? 1;\n\n  // Canvas ref for effects\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [mousePos, setMousePos] = useState({ x: -9999, y: -9999 });\n\n  useEffect(() => {\n    // Only run canvas logic if effects are enabled or hover is on\n    if (effect === \"none\" && !hover) {\n      if (canvasRef.current) {\n        const ctx = canvasRef.current.getContext(\"2d\");\n        if (ctx) ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n      }\n      return;\n    }\n\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    let animationFrameId: number;\n    let startTime = performance.now();\n\n    const render = (timestamp: number) => {\n      if (!containerRef.current) return;\n      \n      const { width: containerWidth, height: containerHeight } = containerRef.current.getBoundingClientRect();\n      \n      // Update canvas size if needed (handling DPI)\n      const dpr = window.devicePixelRatio || 1;\n      if (canvas.width !== containerWidth * dpr || canvas.height !== containerHeight * dpr) {\n        canvas.width = containerWidth * dpr;\n        canvas.height = containerHeight * dpr;\n        canvas.style.width = `${containerWidth}px`;\n        canvas.style.height = `${containerHeight}px`;\n      }\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.save();\n      ctx.scale(dpr, dpr);\n\n      // Pre-calculate common values\n      const cols = Math.ceil(containerWidth / width);\n      const rows = Math.ceil(containerHeight / height);\n      \n      // Time-based variables for effects\n      const time = effectPlaying ? (timestamp - startTime) / 1000 : 0;\n      \n      // Scan effect variables\n      const scanSpeed = 200; // px per second\n      const scanWidth = 150; // width of scan band\n      const scanX = (time * scanSpeed) % (containerWidth + scanWidth * 2) - scanWidth;\n\n      // Pulse effect variables\n      const pulseSpeed = 100; // px per second\n      const pulseMaxRadius = Math.max(containerWidth, containerHeight);\n      const pulseRadius = (time * pulseSpeed) % pulseMaxRadius;\n      const pulseWidth = 200;\n\n      // Draw dots\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          let dotX = j * width + cx + x;\n          let dotY = i * height + cy + y;\n\n          // Apply staggered offset\n          if (mode === \"staggered\" && i % 2 === 1) {\n            dotX += width / 2;\n          }\n\n          // Skip if outside container\n          if (dotX < -width || dotX > containerWidth + width || dotY < -height || dotY > containerHeight + height) continue;\n\n          // Calculate effect intensity (0 to 1)\n          let effectIntensity = 0;\n          let hoverIntensity = 0;\n\n          // Glow effect: Random-looking pulse for each dot\n          if (effect === \"glow\") {\n            // Deterministic \"random\" based on position\n            const seed = (i * cols + j) * 123.45;\n            const freq = 0.5 + (seed % 1); // 0.5 to 1.5 Hz\n            const phase = seed % (Math.PI * 2);\n            // Oscillate between 0 and 1\n            effectIntensity = (Math.sin(time * Math.PI * 2 * freq + phase) + 1) / 2;\n          }\n\n          // Scan effect: Vertical band moving right\n          if (effect === \"scan\") {\n            const dist = Math.abs(dotX - scanX);\n            if (dist < scanWidth) {\n              // Smooth falloff from center of scan band\n              effectIntensity = Math.pow(1 - dist / scanWidth, 2);\n            }\n          }\n\n          // Pulse effect: Ring expanding from center\n          if (effect === \"pulse\") {\n            const centerX = containerWidth / 2;\n            const centerY = containerHeight / 2;\n            const dist = Math.hypot(dotX - centerX, dotY - centerY);\n            const distFromRing = Math.abs(dist - pulseRadius);\n            \n            if (distFromRing < pulseWidth) {\n              effectIntensity = Math.pow(1 - distFromRing / pulseWidth, 2);\n            }\n          }\n\n          // Hover effect: Radius around mouse\n          if (hover) {\n            const dist = Math.hypot(dotX - mousePos.x, dotY - mousePos.y);\n            const hoverRadius = 120;\n            if (dist < hoverRadius) {\n              hoverIntensity = Math.pow(1 - dist / hoverRadius, 2);\n            }\n          }\n\n          // Combine intensities\n          // We only render the dot if there's some intensity (overlay approach)\n          // OR if we want to redraw base dots. \n          // Strategy: The SVG pattern draws the base (faint) dots.\n          // Canvas draws the \"active\" state on top (brighter/larger/colored).\n          \n          const totalIntensity = Math.min(effectIntensity + hoverIntensity, 1);\n          \n          if (totalIntensity > 0.01) {\n            const currentScale = 1 + totalIntensity * 0.8; // Max 1.8x scale\n            const currentAlpha = opacity + (1 - opacity) * totalIntensity * 0.8; // Boost opacity significantly\n            \n            ctx.fillStyle = color;\n            ctx.globalAlpha = currentAlpha;\n            \n            // Draw shape\n            if (shape === \"square\") {\n              const s = size * currentScale;\n              ctx.fillRect(dotX - s/2, dotY - s/2, s, s);\n            } else if (shape === \"cross\") {\n              const s = size * currentScale;\n              const w = currentStrokeWidth * currentScale; // Scale stroke too? Maybe just size. Let's scale stroke slightly\n              \n              ctx.beginPath();\n              // Vertical\n              ctx.rect(dotX - w/2, dotY - s/2, w, s);\n              // Horizontal\n              ctx.rect(dotX - s/2, dotY - w/2, s, w);\n              ctx.fill();\n            } else {\n              // Circle\n              ctx.beginPath();\n              ctx.arc(dotX, dotY, cr * currentScale, 0, Math.PI * 2);\n              ctx.fill();\n            }\n          }\n        }\n      }\n\n      ctx.restore();\n      if (effectPlaying || hover) {\n        animationFrameId = requestAnimationFrame(render);\n      }\n    };\n\n    if (effectPlaying || hover) {\n      animationFrameId = requestAnimationFrame(render);\n    } else {\n      // Draw once if paused but effect is enabled (to show static state) or hovered\n      render(performance.now());\n    }\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [width, height, x, y, cx, cy, cr, shape, strokeWidth, mode, color, opacity, effect, effectPlaying, hover, mousePos]);\n\n  // Update mouse position\n  const handleMouseMove = (e: React.MouseEvent) => {\n    if (!hover || !containerRef.current) return;\n    const rect = containerRef.current.getBoundingClientRect();\n    setMousePos({\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top,\n    });\n  };\n\n  const handleMouseLeave = () => {\n    setMousePos({ x: -9999, y: -9999 });\n  };\n\n  const getGradientStops = () => {\n    switch (fadeLevel) {\n      case \"strong\":\n        return (\n          <>\n            <stop offset=\"0%\" stopColor=\"white\" stopOpacity=\"1\" />\n            <stop offset=\"30%\" stopColor=\"white\" stopOpacity=\"1\" />\n            <stop offset=\"70%\" stopColor=\"white\" stopOpacity=\"0\" />\n          </>\n        );\n      case \"medium\":\n        return (\n          <>\n            <stop offset=\"0%\" stopColor=\"white\" stopOpacity=\"1\" />\n            <stop offset=\"50%\" stopColor=\"white\" stopOpacity=\"1\" />\n            <stop offset=\"90%\" stopColor=\"white\" stopOpacity=\"0\" />\n          </>\n        );\n      case \"weak\":\n      default:\n        return (\n          <>\n            <stop offset=\"0%\" stopColor=\"white\" stopOpacity=\"1\" />\n            <stop offset=\"70%\" stopColor=\"white\" stopOpacity=\"1\" />\n            <stop offset=\"100%\" stopColor=\"white\" stopOpacity=\"0\" />\n          </>\n        );\n    }\n  };\n\n  const renderShape = (offsetX = 0, offsetY = 0) => {\n    if (shape === \"square\") {\n      return (\n        <rect\n          x={cx - cr + offsetX}\n          y={cy - cr + offsetY}\n          width={size}\n          height={size}\n          fill={color}\n          fillOpacity={opacity}\n        />\n      );\n    }\n\n    if (shape === \"cross\") {\n      return (\n        <g stroke={color} strokeOpacity={opacity}>\n          <line\n            x1={cx - cr + offsetX}\n            y1={cy + offsetY}\n            x2={cx + cr + offsetX}\n            y2={cy + offsetY}\n            strokeLinecap=\"round\"\n            strokeWidth={currentStrokeWidth}\n            vectorEffect=\"non-scaling-stroke\"\n          />\n          <line\n            x1={cx + offsetX}\n            y1={cy - cr + offsetY}\n            x2={cx + offsetX}\n            y2={cy + cr + offsetY}\n            strokeLinecap=\"round\"\n            strokeWidth={currentStrokeWidth}\n            vectorEffect=\"non-scaling-stroke\"\n          />\n        </g>\n      );\n    }\n\n    return (\n      <circle\n        id=\"pattern-circle\"\n        cx={cx + offsetX}\n        cy={cy + offsetY}\n        r={cr}\n        fill={color}\n        fillOpacity={opacity}\n      />\n    );\n  };\n\n  return (\n    <div \n      ref={containerRef}\n      className={cn(\"absolute inset-0 h-full w-full\", className)}\n      onMouseMove={handleMouseMove}\n      onMouseLeave={handleMouseLeave}\n      {...props}\n    >\n      <svg\n        aria-hidden=\"true\"\n        className=\"pointer-events-none absolute inset-0 h-full w-full\"\n      >\n        <defs>\n          <pattern\n            id={id}\n            width={width}\n            height={height}\n            patternUnits=\"userSpaceOnUse\"\n            patternContentUnits=\"userSpaceOnUse\"\n            x={x}\n            y={y}\n          >\n            {renderShape(0, 0)}\n            {offset ? renderShape(offset.x, offset.y) : null}\n          </pattern>\n          {fade ? (\n            <>\n              <radialGradient id={gradientId} cx=\"50%\" cy=\"50%\" r=\"70%\">\n                {getGradientStops()}\n              </radialGradient>\n              <mask id={maskId}>\n                <rect width=\"100%\" height=\"100%\" fill={`url(#${gradientId})`} />\n              </mask>\n            </>\n          ) : null}\n        </defs>\n        <rect\n          width=\"100%\"\n          height=\"100%\"\n          strokeWidth={0}\n          fill={`url(#${id})`}\n          mask={fade ? `url(#${maskId})` : undefined}\n        />\n      </svg>\n      {/* Canvas for effects overlay */}\n      {(effect !== \"none\" || hover) && (\n        <canvas\n          ref={canvasRef}\n          className=\"pointer-events-none absolute inset-0 h-full w-full\"\n          style={{ mask: fade ? `radial-gradient(circle at center, black 0%, black 30%, transparent 70%)` : undefined }} // Simple CSS mask for canvas fade approximation if needed, or rely on SVG mask covering it? \n          // SVG mask is on the rect fill, not the whole div. The canvas sits on top.\n          // To match fade on canvas, we'd need to clear canvas pixels or use CSS mask.\n          // For now let's apply a CSS mask similar to the SVG one if fade is true.\n        />\n      )}\n      {fade && (effect !== \"none\" || hover) && (\n        // Apply CSS mask to container div if fade is on? No, that would fade bg too.\n        // We need to fade the canvas.\n        <style jsx>{`\n          canvas {\n            mask-image: radial-gradient(circle at 50% 50%, black 0%, black ${fadeLevel === 'strong' ? '30%' : fadeLevel === 'medium' ? '50%' : '70%'}, transparent ${fadeLevel === 'strong' ? '70%' : fadeLevel === 'medium' ? '90%' : '100%'});\n            -webkit-mask-image: radial-gradient(circle at 50% 50%, black 0%, black ${fadeLevel === 'strong' ? '30%' : fadeLevel === 'medium' ? '50%' : '70%'}, transparent ${fadeLevel === 'strong' ? '70%' : fadeLevel === 'medium' ? '90%' : '100%'});\n          }\n        `}</style>\n      )}\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:lib"
    }
  ],
  "type": "registry:ui"
}